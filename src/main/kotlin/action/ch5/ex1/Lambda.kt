package action.ch5.ex1

/**
 * 함수형 프로그래밍 : 함수를 값처럼 다룬다.
 */
data class Person(val name: String, val age: Int)

fun findTheOldest(): Person? {
    val people = listOf(Person("Alice", 29), Person("Bob", 31))

    return people.maxByOrNull { it.age } // people.maxByOrNull(Person::age)
}

/**
 * { x: Int, y: Int -> x + y }
 * 코틀린 람다 식은 항상 중괄호로 둘러쌓여 있다.
 *
 * 파라미터가 하나인 경우 default 파라미터 이름인 it를 잘 활용하면 깔끔한 람다를 선언할 수 있다.
 * 다만 중첩된 람다 구조 등에서 남용하면 더 복잡할 수 있으니, 단순한 형태의 람다에서만 사용하자.
 *
 * 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 없기 때문에 타입을 명시해야 한다.
 */

/**
 * 람다가 포획(capture)한 변수
 *
 * 코틀린에서는 자바와 달리 람다에서 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고, 그 변수를 변경할 수도 있다.
 * 이를 람다가 포획한 변수라 한다.
 *
 * 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면
 * 로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있다.
 * 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다.
 *
 * 람다를 실행 시점에 표현하는 데이터 구조는
 * 람다에서 시작하는 모든 참조가 포함된 닫힌(closed) 객체 그래프를 람다 코드와 함께 저장해야 한다.
 * 그런 데이터 구조를 클로저(closure)라고 한다.
 * 함수를 쓸모 있는 1급 시민으로 만들려면 포획한 변수를 제대로 처리해야 하고,
 * 포획한 변수를 제대로 처리하려면 클로저가 꼭 필요하다.
 * 그래서 람다를 클로저라고 부르기도 한다.
 */

/**
 * 컬렉션 함수형 API
 *
 * map, filter, all, any, count, find, groupBy, flatMap, flatten 등
 */

/**
 * 지연 계산(lazy) 컬렉션 연산
 *
 * 컬렉션 함수는 결과를 즉시 생성하며, 이는 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는 것을 의미한다.
 * 시퀀스를 사용하면 중간 임시 컬렉션을 사용하지 않고도 지연 연산을 하여 연쇄할 수 있다.
 *
 * 자바의 스트림과 유사한데, 따로 구현을 제공하는 이유는 안드로이드 등에서 예전 버전 자바를 사용하는 경우
 * 자바8의 스트림이 없기 때문이다.
 * 자바8을 선택하면 코틀린 컬렉션과 시퀀스에서 제공하지 않는 중요한 기능을 사용할 수 있는데,
 * 스트림 연산을 여러 CPU에서 병렬적으로 실행하는 기능이다.
 */
fun sequence(): List<String> {
    val people = listOf(Person("Alice", 29), Person("Bob", 31))

    return people.asSequence()
        .map { it.name }
        .filter { it.startsWith("A") }
        .toList()
}
