package action.ch4.ex1

/**
 * 자바에서는 모든 클래스가 기본적으로 상속 가능하지만, 이로 인해 문제가 생기는 경우가 많다.
 * 기반 클래스를 변경하는 경우 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 '취약'하다.
 *
 * 코틀린의 클래스와 메서드는 기본적으로 final이다.
 * 클래스나 메서드의 상속(오버라이드)을 허용하려면 open 변경자를 붙여야 한다.
 */
interface Clickable {
    fun click()
}

open class RichButton : Clickable {
    fun disable() {} // 이 함수는 final이다.
    open fun animate() {} // 이 함수는 열려 있다. override 가능.
    final override fun click() {} // override 한 메서드는 기본적으로 열려있다. 다시 하위에서 오버라이드 하지 못하게 하려면 final 선언이 필요하다.
}

/**
 * 클래스의 기본 상속 가능 상태가 final이어서 얻을 수 있는 큰 이익은 스마트 캐스트가 가능하다는 점이다.
 * 불변이기 때문에 타입 검사 후에 캐스팅 보장이 가능하다.
 */

/**
 * 가시성 변경자
 *
 * 코틀린에서는 아무 변경자도 없는 경우 선언은 모두 공개(public)된다.
 *
 * 자바의 기본 가시성인 패키지 전용은 코틀린에 없다.
 * 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다.
 * 그 대안으로 internal이라는 새로운 가시성 변경자를 도입했는데, "모듈 내부에서만 볼 수 있음"이라는 뜻이다.
 *
 * 변경자    | 클래스 멤버                      | 최상위 선언
 * -----------------------------------------------------------------------------
 * public    | 모든 곳에서 볼 수 있다.          | 모든 곳에서 볼 수 있다.
 * internal  | 같은 모듈 안에서만 볼 수 있다.   | 같은 모듈 안에서만 볼 수 있다.
 * protected | 하위 클래스 안에서만 볼 수 있다. | (최상위 선언에 적용할 수 없음)
 * private   | 같은 클래스 안에서만 볼 수 있다. | 같은 파일 안에서만 볼 수 있다.
 */

/**
 * 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다.
 */

/**
 * 중첩 클래스
 *
 * 코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다.
 * 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 inner 변경자를 붙여야 한다.
 *
 * 클래스 B 안에 정의된 클래스 A                           | 자바           | 코틀린
 * -----------------------------------------------------------------------------------------
 * 중첩 클래스 (바깥쪽 클래스에 대한 참조를 저장하지 않음) | static class A | class A
 * 내부 클래스 (바깥쪽 클래스에 대한 참조를 저장함)        | class A        | inner class A
 *
 * 내부 클래스 Inner 안에서 바깥쪽 클래스 Outer의 참조에 접근하려면 this@Outer라고 써야 한다.
 */

/**
 * 봉인된 클래스
 *
 * 코틀린 컴파일러는 when을 사용해 Expr 타입의 값을 검사할 때 꼭 디폴트 분기인 else 분기를 덧붙이게 강제한다.
 * 항상 디폴트 분기를 추가하는 게 편하지는 않다.
 * 그리고 디폴트 분기가 있으면 이런 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when이 모든 경우를 처리하는지 제대로 검사할 수 없다.
 * 혹 실수로 새로운 클래스 처리를 잊어버렸더라도 디폴트 분기가 선택되기 때문에 심각한 버그가 발생할 수 있다.
 *
 * 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.
 * sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다.
 *
 * sealed 로 표시된 클래스는 자동으로 open이다.
 */
sealed class Expr { // 기반 클래스를 sealed로 봉인
    class Num(val value: Int) : Expr()
    class Sum(val left: Expr, val right: Expr) : Expr()
}

fun eval(e: Expr): Int =
    when (e) { // when 식이 모든 하위 클래스를 검사하므로 별도의 "else" 분기가 없어도 된다.
        is Expr.Num -> e.value
        is Expr.Sum -> eval(e.right) + eval(e.left)
    }
